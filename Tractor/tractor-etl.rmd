---
title: "Tractor Report"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(pointblank)
library(tidyverse)
library(skimr)
# Use `validate_rmd()` here to set options for the
# pointblank validation workflow within R Markdown documents
tractor <- readr::read_csv("https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2020/2020-09-01/cereal_yields_vs_tractor_inputs_in_agriculture.csv") %>% 
  set_names(nm = c("entity", "code", "year", "tractors", "cereal_yield", "population")) %>% 
  mutate(year = as.integer(year)) %>% 
  filter(entity %in% c("Canada", "United States", "Mexico", "Germany"))
```

### Summary

We can validate data inside of specialized code chunks. The **pointblank** makes this possible by loading it, as above. We'll perform some simple validations using `pointblank` and a lightweight summary w/ `skimr::skim()`.

```{r tractor_table, echo = FALSE}
skimr::skim(tractor)
```

### Agent workflow

We can provide a single, agent-based interrogation inside of a `validate` chunk. Don't put anything else in the chunk though (the agent likes to work alone).

```{r agent, validate = TRUE, echo = TRUE}
tractor %>% 
  create_agent(actions = action_levels(warn_at = 1)) %>% 
  col_vals_between(vars(year), 1961, 2018) %>% 
  col_vals_lt(vars(trac_yield), 1900000, preconditions = ~ . %>% mutate(trac_yield = tractors*cereal_yield), na_pass = TRUE) %>% 
  col_vals_regex(vars(entity), "United States|Canada|Mexico") %>% 
  interrogate()
```

### Step Functions

We can perform validation checks on that table with **pointblank** step functions (inside code chunks where `validate = TRUE`). The results will be initially hidden in the rendered HTML document but can be revealed.

```{r validation_step_functions, validate = TRUE, echo = TRUE}

col_vals_between(tractor, vars(year), 1961, 2018)
col_vals_lt(tractor, vars(trac_yield), 1900000, preconditions = ~ . %>% mutate(trac_yield = tractors*cereal_yield), na_pass = TRUE)
col_vals_regex(tractor, vars(entity), "United States|Canada|Mexico")
```

### Stop if Not

We could also use **pointblank**'s `stop_if_not()` function to generate some predicate-based validation statements.

```{r stop_if_not, validate = TRUE, echo = TRUE}
stop_if_not(tractor %>% pull(cereal_yield) %>% min(na.rm = TRUE) > 1e6)
stop_if_not(tractor %>% distinct(entity) %>% pull(entity) %>% str_detect("United States"))
```

### Chained statements

Note that with multiple **pointblank** step functions chained together, only the first error encountered will be reported.

```{r validate = TRUE, echo = TRUE}
tractor %>% 
  col_exists(columns = vars(entity, year, code)) %>% # this passes validation
  col_vals_between(vars(year), 1961, 2018) %>% 
  col_vals_lt(vars(trac_yield), 1900000, preconditions = ~ . %>% mutate(trac_yield = tractors*cereal_yield), na_pass = TRUE) 
```

### Can validate even with passes

If all validations in a `validate` chunk do not fail, we can still inspect the validation code.

```{r validate = TRUE, echo = TRUE}
tractor %>% 
  col_is_integer(vars(year)) %>% 
  col_vals_gt(vars(tractors), 0.1, na_pass = TRUE)
```
